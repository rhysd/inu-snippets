include c.snip

delete		for
snippet		for
abbr		for(;;) {}
	for (${1}; ${2}; ${3}) {
		${0}
	}

delete		template
snippet		template
abbr		template<>
	template<class ${0:T}>

delete		inc
delete		include
snippet		inc
alias		include,#inc,#include
options		head
abbr		#include <>
	#include <${1}>${0}

snippet		inc_boost
alias		#inc_boost,#include_boost
options		head
abbr		#include <boost/...>
	#include <boost/${1}>${0}

delete		inc2
snippet		inc2
alias		include2,#inc2,#include2
options		head
abbr		#include ".hpp"
	#include "${1}.hpp"${0}

delete		inc_h
snippet		inc_h
alias		include_h,#inc_h,#include_h
options		head
abbr		#include <.h>
	#include <${1}.h>${0}

delete		inc_h2
snippet		inc_h2
alias		include_h2,#inc_h2,#include_h2
options		head
abbr		#include ".h"
	#include "${1}.h"${0}

snippet		cout
abbr		cout << ...;
	std::cout << ${1};${0}

snippet		cerr
abbr		cerr << ...;
	std::cerr << ${1};${0}

snippet		cout_endl
abbr		cout << ... << endl;
	std::${1:cout} << ${1} << std::endl;
	${0}

delete		printf
snippet		printf
abbr		std::printf("...", ...)
alias		std::printf
	std::printf("${1:\\n}", ${2});

snippet		print
abbr		std::printf("...")
	std::print("${1}");

snippet		static_assert_msg
abbr		static_assert(,"")
	static_assert( ${1}, "${2}" );${0}

snippet		decltype
abbr		decltype()
	decltype(${1})${0}

snippet		declval
abbr		declval()
	declval<${1}>()${0}

snippet		namespace
abbr		namespace {}
options		head
	namespace ${1:#:name} {
	${0}
	} // namespace $1

snippet		constexpr_func
abbr		constexpr auto func() -> decltype
options		head
	constexpr auto ${1:#:name}(${2:#:args}) -> decltype($3)
	{
		return ${3:#:body};
	}

snippet		STATIC_ASSERT
abbr		STATIC_ASSERT((condition))
options		word
	STATIC_ASSERT((${1:#:condition}));${0}

snippet		STATIC_ASSERT_NOT
abbr		STATIC_ASSERT_NOT((condition))
options		word
	STATIC_ASSERT_NOT((${1:#:condition}));${0}

snippet		using_template_alias
abbr		template<> using
	template<${1:#:params}>
	using ${2:#:name} = ${0:#:body};

snippet		typename_type
abbr		typename <>::type
	typename ${1}<${0}>::type

delete		class
snippet		class
abbr		class{};
	class ${1:#:name} {
		${0}
	};

snippet		for_range
abbr		for(auto const& : ){}
	for (${1:auto &&} ${2:#:item} : ${3:#:container}) {
		${0}
	}

snippet		static_assert_type
abbr		static_assert(...<...>::value, "...");
options		word
	static_assert(std::is_${1:same}<${2:#:types}>::value, "${3} is not $1");

snippet		static_assert_type_not
abbr		static_assert(...<...>::value, "...");
options		word
	static_assert(!std::is_${1:same}<${2:#:types}>::value, "${3} is $1");

snippet		static_assert
abbr		static_assert(,"")
	static_assert( ${1}, "$1" );${0}

snippet		begin_end
abbr		std::begin(...), std::end(...)
alias		std::begin_end
options		word
	std::begin(${1:#:container}), std::end($1)${0}

snippet		for_iterator
abbr		for(auto i = std::begin(...); ...)
	for (auto itr = std::begin(${1:#:container}); itr != std::end($1); ++itr) {
		${0}
	}

snippet		lambda
abbr		[](){ return ; }
	[${1:#:capture}](${2:auto const& x}){ return ${3:#:body}; }${0}

snippet		lambda_long
abbr		[](){}
	[${1:#:capture}](${2:#:args})${3:#:return_type}{
		${0}
	}

snippet		extern_C
abbr		extern "C" {}
	#ifdef __cplusplus
	extern "C" {
	#endif
	
	${0}
	
	#ifdef __cplusplus
	} // extern "C"
	#endif

snippet		extern_C_simple
abbr		extern "C" {}
	extern "C" {
	
	${0}
	
	} // extern "C"

snippet		def_undef
alias		#def_undef
abbr		#define ... #undef
	#define ${1:#:name}${2:#:args} ${3:#:BODY}
	${0}
	#undef $1

snippet		accumulate
abbr		accumulate()
	accumulate(${1:#:range}, [${2:#:capture}](auto const& acc, auto const& ${3:x}){
			 ${0}
		})

snippet		enum_scoped
abbr		enum struct {}
	enum struct ${1:#:name} {
		${0:#:item} = 0,
	};

snippet		try
abbr		try catch
	try {
		${1:TARGET}
	} catch (${2:e:xception}) {
		${3}
	}

snippet		static_cast
abbr		static_cast<>()
	static_cast<${1:#:to}>(${2})${0}

snippet		reinterpret_cast
abbr		reinterpret_cast<>()
	reinterpret_cast<${1:#:to}>(${2})${0}

snippet		const_cast
abbr		const_cast<>()
	const_cast<${1:#:to}>(${2})${0}

snippet		dynamic_cast
abbr		dynamic_cast<>()
	dynamic_cast<${1:#:to}>(${2})${0}

snippet		raw_string
abbr		R"()"
	R"(${1})"${0}

snippet		noexcept_noexcept
abbr		noexcept(noexcept())
	noexcept(noexcept(${0:#:expr}))

snippet		main_iostream
alias		int_main_iostream
options		head
abbr		#include <iostream> main(){}
	#include <iostream>
	${1:#include <vector>}
	
	int main()
	{
		${0}
	}

snippet		forward
options		word
abbr		forward<decltype()>()
	std::forward<decltype(${1:#:var})>($1)${0}

snippet		endl
options		word
abbr		<< std::endl
	${1:std::cout} << std::endl;${0}

snippet		optional
options		head
abbr		auto maybe = ...
	auto ${1:const} maybe_${2:#:var_name} = ${3:#:initializer};
	assert(maybe_$2);
	auto $1& $2 = *maybe_$2;

snippet		default_copyable
options		head
abbr		T(T const&) = default
	${1:#:name}($1 const&) = default;
	
	$1 &($1 const&) = default;${0}

snippet		default_movable
options		head
abbr		T(T const&) = default
	${1:#:name}($1 &&) = default;
	
	$1 &($1 &&) = default;${0}

snippet		debug_print
options		head
abbr		<< __func__ << ...
	std::cerr << ${1:#:"foo" <<} __func__ << ":" __LINE__ " (" __FILE__ ")" << std::endl;${0}

